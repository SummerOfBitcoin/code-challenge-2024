package main

import (
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "os"
    "strings"
)

// func hash256(input string) string {
//     fmt.Println("txid: ", input)
//     h1 := sha256.Sum256([]byte(input))
//     fmt.Printf("h1: %x\n", h1)
//     h2 := sha256.Sum256(h1[:])
//     fmt.Printf("h2: %x\n", h2)

//     return hex.EncodeToString(h2[:])
// }

func hash256(data string) string {
    // Decode hexadecimal string to byte slice
    rawBytes, _ := hex.DecodeString(data)

    // First SHA256 hash
    hash1 := sha256.Sum256(rawBytes)

    // Second SHA256 hash
    hash2 := sha256.Sum256(hash1[:])

    // Convert hash2 to hexadecimal string
    hashedString := hex.EncodeToString(hash2[:])

    return hashedString
}

func generateMerkleRoot(txids []string) string {
    if len(txids) == 0 {
        return ""
    }
    
    level := make([]string, len(txids))
    copy(level, txids)

    for len(level) > 1 {
        nextLevel := make([]string, 0)

        for i := 0; i < len(level); i += 2 {
            var pairHash string
            if i+1 == len(level) {
                pairHash = hash256(level[i] + level[i])
            } else {
                pairHash = hash256(level[i] + level[i+1])
            }
            nextLevel = append(nextLevel, pairHash)
        }

        level = nextLevel
    }

    fmt.Println("Computed Merkle Root:", level[0])
    return level[0]
}

func CreateMerkleTree() {
    fileName := "test.txt"

    // Read all lines from the file
    data, err := os.ReadFile(fileName)
    if err != nil {
        fmt.Println("Error reading file:", err)
        return
    }

    // Split lines into an array of strings (assuming each line is a txid)(reversed)
    txids := strings.Split(string(data), "\n")

    // Call generateMerkleRoot function with txids from the file
    merkleRoot := generateMerkleRoot(txids)

    // Print the computed Merkle root
    fmt.Println("Computed Merkle Root:", merkleRoot)
}


mine

package main

import (
	"encoding/hex"
	"fmt"
	"os"
	"strings"
)

type MerkleNode struct {
	Left  *MerkleNode
	Data  []byte
	Right *MerkleNode
}

type MerkleTree struct {
	MerkleRoot *MerkleNode
}

func NewMerkleNode(lnode *MerkleNode, rnode *MerkleNode, data []byte) *MerkleNode {
	var mNode MerkleNode = MerkleNode{}
	if lnode == nil && rnode == nil {
		//hash256 of the data
		mNode.Data = reverseBytes(data)
	} else {
		var prevHash []byte = append(lnode.Data, rnode.Data...)
		mNode.Data = (to_sha(to_sha(prevHash)))
	}
	mNode.Left = lnode
	mNode.Right = rnode
	return &mNode
}

func NewMerkleTree(leaves []string) *MerkleNode {
	var nodes []MerkleNode

	for _, leaf := range leaves {
		data, _ := hex.DecodeString(leaf)
		var node MerkleNode = *NewMerkleNode(nil, nil, data)
		nodes = append(nodes, node)
	}

	for len(nodes) > 1 {
		var newLevel []MerkleNode
		for i := 0; i < len(nodes); i += 2 {
			// Handle case where the total number of nodes is odd.
			if len(nodes)%2 != 0 {
				nodes = append(nodes, nodes[len(nodes)-1])
			}
			node := *NewMerkleNode(&nodes[i], &nodes[i+1], nil)
			newLevel = append(newLevel, node)
		}
		nodes = newLevel
	}
	return &nodes[0]

}

// func ReadTransactions(dir string) ([][]byte, error) {
// 	var Txs [][]byte
// 	files, err := os.ReadDir(dir)
// 	Handle(err)
// 	for _, file := range files {
// 		txData, err := jsonData(dir + "/" + file.Name())
// 		Handle(err)
// 		var tx Transaction
// 		err = json.Unmarshal([]byte(txData), &tx)
// 		Handle(err)
// 		serialized, err := serializeTransaction(&tx)
// 		Txs = append(Txs, (to_sha(to_sha(serialized)))) //appending the txid in little endian
// 	}
// 	return Txs, nil
// }

func CreateMerkleTree() {
	fileName := "test.txt"

	// Read all lines from the file
	data, err := os.ReadFile(fileName)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	// Split lines into an array of strings (assuming each line is a txid)(reversed)
	txids := strings.Split(string(data), "\n")

	// Calculate the merkle root:
	merkleRoot := NewMerkleTree(txids)

	fmt.Printf("merkle root; %x\n", merkleRoot.Data)
}
